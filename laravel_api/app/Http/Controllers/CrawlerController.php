<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use Grpc\ChannelCredentials;
use App\Grpc\CrawlerServiceClient; // This will be generated by protobuf later
use Illuminate\Support\Facades\Log;
use App\Models\CrawlTask; // Assuming you have this model
use Illuminate\Support\Facades\Redis; // For direct Redis interaction if needed

class CrawlerController extends Controller
{
    /**
     * Submit a crawl task to the FastAPI crawler core via gRPC.
     *
     * @param Request $request
     * @return \Illuminate\Http\JsonResponse
     */
    public function submitCrawlTask(Request $request)
    {
        $request->validate([
            'url' => 'required|url',
        ]);

        $url = $request->input('url');
        $taskId = uniqid('crawl_'); // Generate a unique task ID

        try {
            // Instantiate gRPC client (requires generated classes)
            $client = new CrawlerServiceClient(env('FASTAPI_GRPC_HOST', 'fastapi_crawler:50051'), [
                'credentials' => ChannelCredentials::createInsecure(),
            ]);
            
            // Create a gRPC request object (replace with your actual generated class)
            $requestProto = new \Crawler\CrawlRequest(); 
            $requestProto->setUrl($url);
            $requestProto->setTaskId($taskId); // Pass task_id to FastAPI

            // Make the gRPC call
            list($response, $status) = $client->Crawl($requestProto)->wait();

            if ($status->code !== \Grpc\STATUS_OK) {
                throw new \Exception("gRPC call failed: " . $status->details);
            }

            // Optional: Store task details in database or Redis (as initial 'pending' state)
            Redis::hset("crawl_task_status:{$taskId}", "status", "dispatched");
            Redis::hset("crawl_task_status:{$taskId}", "url", $url);
            Redis::hset("crawl_task_status:{$taskId}", "dispatched_at", now()->toIso8601String());

            Log::info("gRPC call successful for URL: $url, Task ID: $taskId, Status: " . $response->getStatus());
            return response()->json([
                'message' => 'Crawl task submitted via gRPC',
                'task_id' => $taskId,
                'grpc_response_status' => $response->getStatus(),
            ]);

        } catch (\Exception $e) {
            Log::error("Failed to submit crawl task for URL: $url. Error: " . $e->getMessage());
            // Store failed status in Redis
            Redis::hset("crawl_task_status:{$taskId}", "status", "submission_failed");
            Redis::hset("crawl_task_status:{$taskId}", "error", $e->getMessage());
            return response()->json(['error' => 'Failed to submit crawl task: ' . $e->getMessage()], 500);
        }
    }

    /**
     * Get the status of a submitted crawl task.
     *
     * @param string $taskId
     * @return \Illuminate\Http\JsonResponse
     */
    public function getCrawlStatus(string $taskId)
    {
        // Prioritize fetching from Redis for real-time status
        $redisStatus = Redis::hgetall("crawl_task_status:{$taskId}");
        if ($redisStatus && isset($redisStatus['status'])) {
            return response()->json([
                'task_id' => $taskId,
                'status' => $redisStatus['status'],
                'progress' => ($redisStatus['status'] === 'completed' || $redisStatus['status'] === 'failed') ? '100%' : 'pending',
                'url' => $redisStatus['url'] ?? null,
                'dispatched_at' => $redisStatus['dispatched_at'] ?? null,
                'completed_at' => $redisStatus['completed_at'] ?? null,
                'error' => $redisStatus['error'] ?? null,
                'source' => 'redis'
            ]);
        }
        
        // Fallback to database if not found in Redis (or for historical data)
        $task = \App\Models\CrawlTask::where('task_id', $taskId)->first();
        if ($task) {
            return response()->json([
                'task_id' => $taskId,
                'url' => $task->url,
                'status' => $task->status,
                'progress' => $task->completed_at ? '100%' : 'pending',
                'started_at' => $task->started_at,
                'completed_at' => $task->completed_at,
                'error_message' => $task->error_message,
                'source' => 'database'
            ]);
        }

        return response()->json(['error' => 'Task not found or no status available'], 404);
    }
}
